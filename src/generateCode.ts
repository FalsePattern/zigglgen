import type { ResolvedFeatures } from "./resolveFeatures.js"

const ZIGGLGEN_VERSION = "0.1"
const ZIGGLGEN_URL = "https://github.com/castholm/zigglgen"

export function generateCode(features: ResolvedFeatures, apiDisplayName: string): string {
  const sb: string[] = []
  const timestamp = new Date().toISOString().slice(0, 19) + "Z"
  const hasExtensions = !!features.extensions.size

  sb.push("// This is free and unencumbered software released into the public domain.\n")
  sb.push("\n")
  sb.push(`//! Zig binding for ${apiDisplayName}.\n`)
  sb.push(`//!\n`)
  sb.push(`//! Generated by [zigglgen ${ZIGGLGEN_VERSION}](${ZIGGLGEN_URL}) on ${timestamp}.\n`)
  sb.push("\n")
  sb.push("/// Initializes the OpenGL binding. This function must be called before calling any other function\n")
  sb.push("/// declared by the OpenGL binding.\n")
  sb.push("///\n")
  sb.push("/// `loader` must be an instance, or a pointer to an instance, of a type that declares the function")
  if (hasExtensions) {
    sb.push("s")
  }
  sb.push("\n")
  sb.push("///\n")
  sb.push("/// - `fn getCommandFnPtr(loader: LoaderRef, command_name: [:0]const u8) !CommandFnPtr`")
  if (hasExtensions) {
    sb.push(" and\n")
    sb.push("/// - `fn extensionSupported(loader: LoaderRef, extension_name: [:0]const u8) !bool`")
  }
  sb.push("\n")
  sb.push("///\n")
  sb.push("/// where\n")
  sb.push("///\n")
  sb.push("/// - `LoaderRef` is one of `@This()`, `*@This()` or `*const @This()` and\n")
  sb.push("/// - `CommandFnPtr` is a function pointer type that can be coerced to `*const anyopaque`.\n")
  sb.push("///\n")
  sb.push("/// It is safe for the caller to free `loader` after this function returns.\n")
  sb.push("pub fn init(loader: anytype) !void {\n")
  sb.push("    state = try State.init(loader);\n")
  sb.push("}\n")
  sb.push("\n")
  sb.push("//#region Types\n")
  for (const type of features.types.values()) {
    sb.push(`pub const ${type.name} = ${type.type};\n`)
  }
  sb.push("//#endregion Types\n")
  sb.push("\n")
  sb.push("//#region Constants\n")
  for (const constant of features.constants.values()) {
    sb.push(`pub const @"${constant.name}" = ${constant.value};\n`)
  }
  sb.push("//#endregion Constants\n")
  sb.push("\n")
  sb.push("//#region Commands\n")
  for (const command of features.commands.values()) {
    sb.push(`pub fn @"${command.name}"(`)
    sb.push(command.params.map(x => `@"${x.name}": ${x.type}`).join(", "))
    sb.push(`) callconv(.C) ${command.type} {\n`)
    sb.push(`    return @call(.always_tail, state.commands.@"${command.name}"`)
    if (command.optional) {
      sb.push(".?")
    }
    sb.push(`, .{`)
    sb.push(command.params.map(x => `@"${x.name}"`).join(", "))
    sb.push("});\n")
    sb.push("}\n")
    sb.push("\n")
  }
  sb.pop()
  sb.push("//#endregion Commands\n")
  sb.push("\n")
  if (hasExtensions) {
    sb.push("/// Gets a boolean value indicating whether the specified OpenGL extension is supported.\n")
    sb.push("pub fn extensionSupported(extension: enum {\n");
    for (const extension of features.extensions.values()) {
      sb.push(`    @"${extension.name}",\n`)
    }
    sb.push("}) bool {\n");
    sb.push("    return @field(state.extensions, @tagName(extension));\n");
    sb.push("}\n");
    sb.push("\n");
  }
  sb.push("/// The current state of the OpenGL binding.\n")
  sb.push("pub var state: State = undefined;\n")
  sb.push("\n")
  sb.push("/// OpenGL binding state.\n")
  sb.push("pub const State = struct {\n")
  sb.push("    commands: Commands,\n")
  if (hasExtensions) {
    sb.push("    extensions: Extensions = .{},\n")
  }
  sb.push("\n")
  sb.push("    pub fn init(loader: anytype) !State {\n")
  sb.push("        var s = State{\n")
  sb.push("            .commands = .{\n")
  for (const command of features.commands.values()) {
    sb.push(`                .@"${command.name}" = try getCommandFnPtr("${command.name}", loader, "${command.key}"),\n`)
  }
  sb.push("            },\n")
  sb.push("        };\n")
  for (const extension of features.extensions.values()) {
    sb.push(`        if (try loader.extensionSupported("${extension.key}")) {\n`)
    for (const command of extension.commands.map(x => features.commands.get(x)!)) {
      sb.push(`            s.commands.@"${command.name}" = try getCommandFnPtr("${command.name}", loader, "${command.key}");\n`)
    }
    sb.push(`            s.extensions.@"${extension.name}" = true;\n`)
    sb.push(`        }\n`)
  }
  sb.push("        return s;\n")
  sb.push("    }\n")
  sb.push("\n")
  sb.push("    pub const Commands = struct {\n")
  for (const command of features.commands.values()) {
    sb.push(`        @"${command.name}": `)
    if (command.optional) {
      sb.push("?")
    }
    sb.push("*const fn (")
    sb.push(command.params.map(x => `@"${x.name}": ${x.type}`).join(", "))
    sb.push(`) callconv(.C) ${command.type}`)
    if (command.optional) {
      sb.push(" = null")
    }
    sb.push(",\n")
  }
  sb.push("    };\n")
  sb.push("\n")
  if (hasExtensions) {
    sb.push("    pub const Extensions = struct {\n")
    for (const extension of features.extensions.values()) {
      sb.push(`        @"${extension.name}": bool = false,\n`)
    }
    sb.push("    };\n")
    sb.push("\n")
  }
  sb.push("    fn getCommandFnPtr(\n")
  sb.push("        comptime field_name: []const u8,\n")
  sb.push("        loader: anytype,\n")
  sb.push("        command_name: [:0]const u8,\n")
  sb.push("    ) !CommandFnPtr(field_name) {\n")
  sb.push("        return @ptrCast(CommandFnPtr(field_name), try loader.getCommandFnPtr(command_name));\n")
  sb.push("    }\n")
  sb.push("\n")
  sb.push("    fn CommandFnPtr(comptime field_name: []const u8) type {\n")
  sb.push("        return @TypeOf(@field(@as(Commands, undefined), field_name));\n")
  sb.push("    }\n")
  sb.push("};\n")

  return sb.join("")
}
