import type { ResolvedFeatures } from "./resolveFeatures.js"

const NOTICE = [
  "// NOTICE\n",
  "//\n",
  "// This work uses definitions from the OpenGL XML API Registry\n",
  "// <https://github.com/KhronosGroup/OpenGL-Registry>.\n",
  "// Copyright 2013-2020 The Khronos Group Inc.\n",
  "// Licensed under Apache-2.0.\n",
  "//\n",
  "// END OF NOTICE\n",
].join("")

const ZIGGLGEN_VERSION = "0.1"
const ZIGGLGEN_URL = "https://github.com/castholm/zigglgen"

export function generateCode(features: ResolvedFeatures, apiProfileVersion: string): string {
  const sb: string[] = []
  const timestamp = new Date().toISOString().slice(0, 19) + "Z"
  const hasExtensions = !!features.extensions.size

  sb.push(NOTICE)
  sb.push("\n")
  sb.push(`//! Zig binding for ${apiProfileVersion}.\n`)
  sb.push(`//!\n`)
  sb.push(`//! Generated by [zigglgen ${ZIGGLGEN_VERSION}](${ZIGGLGEN_URL}) on ${timestamp}.\n`)
  sb.push("\n")
  sb.push("/// Initializes the OpenGL binding. This function must be called before calling any other function\n")
  sb.push("/// declared by the OpenGL binding.\n")
  sb.push("///\n")
  sb.push("/// `loader` must be an instance, or a pointer to an instance, of a type that declares the function")
  if (hasExtensions) {
    sb.push("s")
  }
  sb.push("\n")
  sb.push("///\n")
  sb.push("/// - `pub fn getCommandFnPtr(loader: LoaderRef, command_name: [:0]const u8) !CommandFnPtr`")
  if (hasExtensions) {
    sb.push(" and\n")
    sb.push("/// - `pub fn extensionSupported(loader: LoaderRef, extension_name: [:0]const u8) !bool`,\n")
  } else {
    sb.push(",\n")
  }
  sb.push("///\n")
  sb.push("/// where\n")
  sb.push("///\n")
  sb.push("/// - `LoaderRef` is equivalent to `@This()`, `*@This()` or `*const @This()` and\n")
  sb.push("/// - `CommandFnPtr` is a function pointer type that can be coerced to `*const anyopaque`.\n")
  sb.push("///\n")
  sb.push("/// It is safe for the caller to free `loader` after this function returns.\n")
  sb.push("pub fn init(loader: anytype) !void {\n")
  sb.push("    state = try State.init(loader);\n")
  sb.push("}\n")
  sb.push("\n")
  if (hasExtensions) {
    sb.push("/// Gets a boolean value indicating whether the specified OpenGL extension is supported.\n")
    sb.push("pub inline fn extensionSupported(extension: Extension) bool {\n");
    sb.push("    return @field(state.extensions, @tagName(extension));\n");
    sb.push("}\n");
    sb.push("\n");
  }
  sb.push("//#region Types\n")
  for (const type of features.types.values()) {
    sb.push(`pub const ${type.name} = ${type.type};\n`)
  }
  sb.push("//#endregion Types\n")
  sb.push("\n")
  sb.push("//#region Constants\n")
  for (const constant of features.constants.values()) {
    sb.push(`pub const ${zigIdentifier(constant.name)} = ${constant.value};\n`)
  }
  sb.push("//#endregion Constants\n")
  sb.push("\n")
  sb.push("//#region Commands\n")
  for (const command of features.commands.values()) {
    sb.push(`pub fn ${zigIdentifier(command.name)}(`)
    sb.push(command.params.map(x => `${zigIdentifier(x.name)}: ${x.type}`).join(", "))
    sb.push(`) callconv(.C) ${command.type} {\n`)
    sb.push(`    return @call(.always_tail, state.commands.${zigIdentifier(command.name)}`)
    if (command.optional) {
      sb.push(".?")
    }
    sb.push(`, .{`)
    if (command.params.length > 1) {
      sb.push(" ")
    }
    sb.push(command.params.map(x => `${zigIdentifier(x.name)}`).join(", "))
    if (command.params.length > 1) {
      sb.push(" ")
    }
    sb.push("});\n")
    sb.push("}\n")
  }
  sb.push("//#endregion Commands\n")
  sb.push("\n")
  if (hasExtensions) {
    sb.push("/// OpenGL extensions available to the OpenGL binding.\n")
    sb.push("pub const Extension = enum {\n")
    for (const extension of features.extensions.values()) {
      sb.push(`    ${zigIdentifier(extension.name)},\n`)
    }
    sb.push("};\n")
    sb.push("\n")
  }
  sb.push("/// The current state of the OpenGL binding.\n")
  sb.push("pub var state: State = undefined;\n")
  sb.push("\n")
  sb.push("/// OpenGL binding state.\n")
  sb.push("pub const State = struct {\n")
  sb.push("    commands: Commands,\n")
  if (hasExtensions) {
    sb.push("    extensions: Extensions = .{},\n")
  }
  sb.push("\n")
  sb.push("    pub fn init(loader: anytype) !State {\n")
  sb.push("        var s = State{\n")
  sb.push("            .commands = .{\n")
  for (const command of features.commands.values()) {
    sb.push(`                .${zigIdentifier(command.name)} = try getCommandFnPtr("${command.name}", loader, "${command.key}"),\n`)
  }
  sb.push("            },\n")
  sb.push("        };\n")
  for (const extension of features.extensions.values()) {
    sb.push(`        if (try loader.extensionSupported("${extension.key}")) {\n`)
    for (const command of extension.commands.map(x => features.commands.get(x)!)) {
      sb.push(`            s.commands.${zigIdentifier(command.name)} = try getCommandFnPtr("${command.name}", loader, "${command.key}");\n`)
    }
    sb.push(`            s.extensions.${zigIdentifier(extension.name)} = true;\n`)
    sb.push(`        }\n`)
  }
  sb.push("        return s;\n")
  sb.push("    }\n")
  sb.push("\n")
  sb.push("    pub const Commands = struct {\n")
  for (const command of features.commands.values()) {
    sb.push(`        ${zigIdentifier(command.name)}: `)
    if (command.optional) {
      sb.push("?")
    }
    sb.push("*const fn (")
    sb.push(command.params.map(x => `${zigIdentifier(x.name)}: ${x.type}`).join(", "))
    sb.push(`) callconv(.C) ${command.type}`)
    if (command.optional) {
      sb.push(" = null")
    }
    sb.push(",\n")
  }
  sb.push("    };\n")
  sb.push("\n")
  if (hasExtensions) {
    sb.push("    pub const Extensions = struct {\n")
    for (const extension of features.extensions.values()) {
      sb.push(`        ${zigIdentifier(extension.name)}: bool = false,\n`)
    }
    sb.push("    };\n")
    sb.push("\n")
  }
  sb.push("    fn getCommandFnPtr(\n")
  sb.push("        comptime field_name: []const u8,\n")
  sb.push("        loader: anytype,\n")
  sb.push("        command_name: [:0]const u8,\n")
  sb.push("    ) !CommandFnPtr(field_name) {\n")
  sb.push("        return @ptrCast(CommandFnPtr(field_name), try loader.getCommandFnPtr(command_name));\n")
  sb.push("    }\n")
  sb.push("\n")
  sb.push("    fn CommandFnPtr(comptime field_name: []const u8) type {\n")
  sb.push("        return @TypeOf(@field(@as(Commands, undefined), field_name));\n")
  sb.push("    }\n")
  sb.push("};\n")
  sb.push("\n")
  sb.push("test {\n")
  sb.push("    @setEvalBranchQuota(10_000);\n")
  sb.push('    @import("std").testing.refAllDeclsRecursive(@This());\n')
  sb.push("}\n")

  return sb.join("")
}

const ZIG_UNQUOTED_IDENTIFIER_REGEX = RegExp(`^(?!(${[
  "_",

  // https://github.com/ziglang/zig/blob/07630eb696a4c7097fadf9e0261411d591a82038/lib/std/zig/tokenizer.zig#L12-L62
  "addrspace",
  "align",
  "allowzero",
  "and",
  "anyframe",
  "anytype",
  "asm",
  "async",
  "await",
  "break",
  "callconv",
  "catch",
  "comptime",
  "const",
  "continue",
  "defer",
  "else",
  "enum",
  "errdefer",
  "error",
  "export",
  "extern",
  "fn",
  "for",
  "if",
  "inline",
  "linksection",
  "noalias",
  "noinline",
  "nosuspend",
  "opaque",
  "or",
  "orelse",
  "packed",
  "pub",
  "resume",
  "return",
  "struct",
  "suspend",
  "switch",
  "test",
  "threadlocal",
  "try",
  "union",
  "unreachable",
  "usingnamespace",
  "var",
  "volatile",
  "while",

  // https://github.com/ziglang/zig/blob/07630eb696a4c7097fadf9e0261411d591a82038/lib/std/zig/primitives.zig
  "anyerror",
  "anyframe",
  "anyopaque",
  "bool",
  "c_int",
  "c_long",
  "c_longdouble",
  "c_longlong",
  "c_short",
  "c_uint",
  "c_ulong",
  "c_ulonglong",
  "c_ushort",
  "comptime_float",
  "comptime_int",
  "f128",
  "f16",
  "f32",
  "f64",
  "f80",
  "false",
  "isize",
  "noreturn",
  "null",
  "true",
  "type",
  "undefined",
  "usize",
  "void",
  "([iu][0-9]+)",
].join("|")})$)[A-Z_a-z][0-9A-Z_a-z]*$`)

function zigIdentifier(identifier: string): string {
  return ZIG_UNQUOTED_IDENTIFIER_REGEX.test(identifier) ? identifier : `@"${identifier}"`
}
